\documentclass{article}

\usepackage{arxiv}
\usepackage[utf8]{inputenc} 
\usepackage[T1]{fontenc}    
\usepackage{hyperref}      
\usepackage{url}            
\usepackage{booktabs}       
\usepackage{amsfonts}       
\usepackage{nicefrac}       
\usepackage{microtype}      
\usepackage{cleveref}       
\usepackage{graphicx}
\usepackage{natbib}
\usepackage{doi}
\usepackage[portuguese]{babel}
\usepackage{caption}
\usepackage{braket}
\usepackage{amsmath}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{mathtools}

\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}

\makeatletter
\renewcommand\subsubsubsection{\@startsection{paragraph}{4}{\z@}{-2.5ex\@plus -1ex \@minus -.25ex}{1.25ex \@plus .25ex}{\normalfont\normalsize\bfseries}}
\newcommand\subsubsubsubsection{\@startsection{subparagraph}{5}{\z@}{-2.5ex\@plus -1ex \@minus -.25ex}{1.25ex \@plus .25ex}{\normalfont\normalsize\bfseries}}
\makeatother


\title{Quantum Oracles - Como transformar problemas clássicos em quânticos}

\date{\today}



\author{ 
	\href{https://orcid.org/0009-0008-9134-5974}{\includegraphics[scale=0.06]{orcid.pdf}\hspace{1mm}Alexandre Silva}\\
	Ciências da Computação\\
	UNIVEM - Centro Universitário Eurípides de Marília\\
	\And
	\href{http://lattes.cnpq.br/5170103189904688}{\hspace{1mm}Luis Hilário Tobler Garcia} \\
	Ciências da Computação\\
	UNIVEM - Centro Universitário Eurípides de Marília\\
	\And
	\href{http://lattes.cnpq.br/7265559606596355}{\hspace{1mm}Maúricio Duarte} \\
	Tecnologia da Informação \\
	Fatec Garça – Deputado Julio Julinho Marcondes de Moura\\
}

\graphicspath{ {../images/} }

\renewcommand{\headeright}{}
\renewcommand{\undertitle}{}
\renewcommand{\shorttitle}{}


\hypersetup{
	pdftitle={Quantum Oracles - Como transformar problemas classicos em quanticos},
	pdfsubject={quantum computing, computer science, ciências da computação, computação quântica, algoritmos, algorithms, problem solving, problems, solução de problemas, problemas},
	pdfauthor={Alexandre Silva},
	pdfkeywords={quantum oracles, quantum, quantum computing, algoritmos, algorithms, problems, problemas},
}

\begin{document}
\maketitle
\begin{abstract}
	A partir do uso de quantum Oracles e outros fatores quânticos, como a superposição, foram feitos \emph{5 mini-projetos}. O objetivo desses projetos foi tentar responder se é possível transformar certos problemas em quânticos e se realmente tal transformação vale a pena. Após os testes foi possível ver que, há casos em que a versão quântica apresenta um aproveitamento igual ou um pouco superior, contudo ainda é necessário o uso de computadores clássicos para conseguir melhores resultados.
\end{abstract}


\section{Introdução}
Hoje, não é difícil ver alguém falando sobre computadores quânticos e como essas máquinas vão mudar o nosso futuro. Contudo, muitas dessas frases acabam se levando por extrapolações e/ou usos indevidos de ficção. Neste artigo, mostrarei que nem tudo é possível ser feito com um computador quântico atual, assim como existem pequenas áreas que se beneficiam ao máximo dessa nova tecnologia.\\
Para esse feito, serão mostrados \emph{5 mini-projetos} usando o \href{https://www.ibm.com/quantum/qiskit}{qiskit}, framework open source da \href{https://www.ibm.com/}{IBM}, e os resultados obtidos após executar os algoritmos quânticos e seus relativos em computação clássica.\\
Tais mini-projetos foram os seguintes: Explorador de Arquivos \ref{file-explorer}, conversão de milhas para quilômetros \ref{conversion}, Torres de Hanoi \ref{hanoi}, Buckshot Roulette \ref{buckshot} e QRAM \ref{qram}. Todas as implementações podem ser encontradas nesse  \href{https://github.com/Dpbm/scientific-initiation-1-quantum-oracles}{repositório do GitHub}.\\
Para a criação desses projetos, foram usados os Quantum Oracles em conjunto com alguns algoritmos, explorando efeitos quânticos e algumas outras técnicas, clássicas e quânticas, para cada caso específico.

\section{Oracles}
Partindo da ideia das \emph{Oracle Turing Machines} \cite{SOARE2009368}\cite{amreen_oracle}\cite{kalyanasyndaram_2021_mod04lec23}\cite{e21080800}, os Oracles são modelos matemáticos ideais, usados para abstrair certas partes de um algoritmo principal, em formato de caixa preta, facilitando a análise do algoritmo, assim como sua descrição matemática. Tais máquinas podem ser vistas, também, como uma função, recebendo uma entrada $x$ e retornando $f(x)$ em tempo $O(1)$. Em computação clássica, esse modelo não possui implementação real, sendo usado apenas descrições formais para problemas de decisão.\\
Contudo, em computação quântica, é possível implementar esses componentes e tomar proveito de sua estrutura e efeitos quânticos para conseguir um \emph{Speed-up} em relação aos algoritmos clássicos, como mostrado pelo algoritmo de Deutsch–Jozsa \cite{Fan_2007}. Além disso, os Oracles possuem um papel importante ao demonstrar a complexidade de um circuito, alguns dos meios utilizados são: profundidade (\emph{depth}), calculando o maior caminho que uma informação percorre no circuito, ou ainda, a quantidade de gates aplicados. No entanto, essas maneiras acabam se prejudicando ao \emph{transpilar} o circuito para uma outra máquina, variando então a complexidade de acordo com a topologia e com os gates fisicamente implementados. Para solucionar isso, outra maneira de calcular é inserir partes do circuito em um Oracle, e descrever sua complexidade a partir da quantidade de vezes que ele chamado, também conhecido como \emph{query complexity} \cite{odonnell_2015_lecture} \cite{e21080800}.

\subsection{Tipos de Oracles}
A partir da definição dos Quantum Oracles, podemos classificá-los em relação a suas estruturas e maneiras de computar os dados.

\subsubsection{Phase Oracle}
O Phase Oracle, é o formato mais conhecido e usado em circuitos quânticos. Algoritmos como os de  Deutsch–Jozsa, Grover, Simon e Bernstein–Vazirani, tomam proveito desse artifício para se sobressair em relação às soluções clássicas. 

\subsubsubsection{Funcionamento Padrão}
Seu funcionamento, se baseia em atribuir uma fase global ao circuito, tomando proveito de fatores como \emph{Phase Kickback} (fase passa do target do CNOT e é aplicado no qubit de controle), para  conseguir modificar valores em superposição.

\begin{center}
	\includegraphics[scale=0.3]{phase_oracle_1.png}
	\captionof{figure}{Exemplo - Phase Oracle}
	\label{fig:phase-oracle-1}
\end{center}

Na Imagem \ref{fig:phase-oracle-1}, foi introduzida uma fase $\pi$ no qubit auxiliar ($q3$) através do estado  $\ket{-}$. Essa fase será responsável por modificar os valores na matriz unitária final. Nessa configuração, os CNOTs agem de uma forma um tanto diferente do convencional, aqui,  ao invés de apenas inverter o valor do qubit no target quando o qubit de controle for $1$, devido a fase, ele também agirá como um gate $Z$ sendo aplicado no estado do qubit de controle. Sendo assim, ao aplicar $CNOT\ket{-}\ket{+}$ (qubit menos significativo à direita), o estado se torna ${\frac{1}{\sqrt{2}}}{(\ket{0}\ket{-} - \ket{1}\ket{-})}$, e ao remover a superposição com o $H$, a saída se torna: ${\frac{1}{\sqrt{2}}}{(\ket{+}\ket{1} - \ket{-}\ket{1})}$. Dessa forma, o qubit que antes estava como controle do gate, sofre a ação do \emph{Phase Kickback}, e seu estado padrão $\ket{0}$ é modificado pela fase e se torna $\ket{1}$. A partir disso, é possível encodar um certo valor binário dentro do Oracle e utilizá-lo para cálculos. 

\subsubsubsection{Versão Minimal Oracle}
Além disso, esse não é o único formato possível de Phase Oracle. Por apenas aplicar uma fase em certas bit-strings, o qubit auxiliar pode ser removido, e a fase pode ser adicionada através de gates $Z$controlados (ou outro gate capaz de aplicar uma fase $\pi$ para certa bit-string), mas ainda assim mantendo a natureza unitária, podendo ser visto também como um Minimal Oracle.

\begin{center}
	\includegraphics[scale=0.3]{phase_oracle_2.png}
	\captionof{figure}{Exemplo Phase Oracle como um Minimal Oracle}
	\label{fig:phase-oracle-2}
\end{center}

No exemplo da imagem \ref{fig:phase-oracle-2}, foi adicionado um gate $MCP$ com a fase global $\pi$ e dois gates $X$ para inverter os qubits queremos que tenham o valor $0$, codificando assim o valor $011_{2}$ ou $3_{10}$.

\begin{center}
	\includegraphics[scale=0.5]{phase_oracle_unitary.png}
	\captionof{figure}{Matriz unitária do Phase Oracle da imagem \ref{fig:phase-oracle-2}}
	\label{fig:phase-oracle-unitary}
\end{center}

Assim, é possível verificar que ao criar esse circuito, é mantida a matriz identidade mas com a fase ($-1$) no valor $1$ na coluna relativa à $011_{2}$ (figura \ref{fig:phase-oracle-unitary}). 


\subsubsection{Boolean Oracle}
O Boolean Oracle, por sua vez, apresenta um funcionamento semelhante ao do Phase Oracle. Contudo, neste não é provida uma fase. Dessa forma, o Oracle age como uma função Booleana convencional, mapeando as entradas para valores de saída.

\begin{center}
	\includegraphics[scale=0.3]{balanced-oracle.png}
	\captionof{figure}{Exemplo de Oracle Booleano}
	\label{fig:boolean-oracle}
\end{center}

O Oracle implementado na figura \ref{fig:boolean-oracle}, pode ser reutilizado para o algoritmo de Deutsch-Jozsa, bastando apenas introduzir uma fase, e o Boolean Oracle se comportará como um Phase Oracle.

\subsubsection{Minimal Oracle}

Como já citado anteriormente, o Minimal Oracle possui uma função que, em sua essência, é unitária, não requerendo qubits adicionais. Sendo assim, este pode ser tanto Booleano como um Phase Oracle dependendo de sua implementação.

\begin{center}
	\includegraphics[scale=0.3]{minimal-oracle.png}
	\captionof{figure}{Exemplo de Minimal Oracle}
	\label{fig:minimal-oracle}
\end{center}

No exemplo da figura \ref{fig:minimal-oracle}, foram utilizados dois $SWAP$ para inverter a ordem dos valores. Com isso, a matriz final ainda se mantém unitária, com apenas valores invertidos em certas posições.


\subsubsection{QFT(Quantum Fourier Transform)}

O QFT, em suma, é um algoritmo quântico usado para projetar os valores da base computacional para a base $X$ (ou também conhecido como base de Fourier), ou vice-versa usando sua função inversa $QFT^{-1}$. Esse algoritmo, toma como base a transformada discreta de Fourier e aplica essa transformação em estados quânticos.\\
Mesmo sendo um algoritmo por si só, sua aplicação em circuitos se dá seguindo o formato de Oracles.

\begin{center}
	\includegraphics[scale=0.3]{QFT_1.png}
	\captionof{figure}{Exemplo do Oracle de QFT}
	\label{fig:QFT}
\end{center}

\begin{center}
	\includegraphics[scale=0.3]{QFT_1_transpiled.png}
	\captionof{figure}{Exemplo do Oracle de QFT transpilado usando o simulador AER do Qiskit}
	\label{fig:QFT-transpiled}
\end{center}

\begin{center}
	\includegraphics[scale=0.3]{QFT_1_bloch.png}
	\captionof{figure}{Valores mapeados na base de Fourier}
	\label{fig:QFT-bloch}
\end{center}


\subsubsection{Outros Oracles}

Além dos Oracles citados, é possível encontrar na literatura citações descrevendo o Oracle de Simon, o Oracle de Deutsch-Jozsa, etc. No entanto, esses são implementações de Oracles já citados e, além disso, para o desenvolvimento deste projeto, os Oracles mais relevantes são o Phase Oracle e o Boolean Oracle. Portanto, não há a necessidade de profundas investigações para essas subcategorias de Oracles.


\section{Desenvolvimento}

Com alguns algoritmos testados e com o uso dos Oracles em mente, os 5 mini-projetos foram desenvolvidos.

\subsection{Explorador de Arquivos} \label{file-explorer}

Imagine um computador quântico, utilizando um sistema operacional quântico (semelhante aos computadores convencionais, mas dessa vez seguindo as leis da mecânica quântica). Pensando nas partes desse sistema operacional, como seria possível pegar arquivos da memória usando a computação quântica?

É importante salientar que nesse suposto computador quântico, temos também acesso à uma máquina clássica, assim como a maioria dos computadores quânticos atuais.

\subsubsection{Algoritmos usados}

\subsubsection{Grover}

O algoritmo evidente para esse problema é o algoritmo de Grover. Este realiza buscas em "bancos de dados" (bit strings) desorganizados em tempo $O(\sqrt{2^n})$ onde $n$ é o número de qubits usados. 
Nele, usamos um circuito do qual amplifica-se as probabilidades de encontrar os valores marcados no Oracle.

\begin{center}
	\includegraphics[scale=0.3]{Grover.png}
	\captionof{figure}{Exemplo algoritmo de Grover}
	\label{fig:grover-default-circuit}
\end{center}

Há ainda uma relação para determinar a quantidade $k$ de vezes necessárias para adicionar o conjunto $Oracle + Diffuser$ sendo essa: $k \approx { {\pi \over {4 \sqrt{a\over{2^n}}}} - {1\over2}  }$, do qual $a$ representa o número de valores marcados pelo Oracle. Contudo, para esse projeto, não há necessidade, uma vez que queremos procurar um arquivo único em meio aos inúmeros armazenados na memória.

Mesmo sendo o melhor algoritmo conhecido para buscas em computação quântica, foi testado também hipóteses para possíveis maneiras de melhor os valores das distribuições finais. Para isso, foram testadas inúmeras combinações de rotações $RY$ e comparadas com o convencional usado pelo algoritmo $H$.

\begin{center}
	\includegraphics[scale=0.5]{improvement-grover-algorithm-4bits-0-to-2pi.png}
	\captionof{figure}{Comparação usando o algoritmo de Grover convencional e o algoritmo modificado usando o melhor ângulo $[0, 2\pi]$ para cada bit-string de quatro bits}
	\label{fig:best-angle-grover}
\end{center}

Com isso, é possível ver que na maior parte das vezes, utilizar ângulos próprios para cada bit-string se sobressai ao valor padrão.

\begin{center}
	\includegraphics[scale=0.4]{new-grover-test-different-bit-strings-with-optimal-angles.png}
	\captionof{figure}{Teste utilizando os melhores ângulos de cada bit-string em bit-strings diferentes}
	\label{fig:best-angles-diff-bit-strings-grover}
\end{center}

No entanto, ao utilizar esses valores com outras bit-strings, os resultados não conseguem alcançar tal limiar, sendo a rotação padrão  melhor na maioria das vezes.

Além disso, para bit-strings de dois bits, utilizar a superposição dada por $H$ é a melhor alternativa.

\begin{center}
	\includegraphics[scale=0.5]{classical_grover_for_1_bit_strings_l2_outcomes.png}
	\captionof{figure}{Resultado Grover padrão encodado uma bit-string de 2 bits}
	\label{fig:l2-grover-classical-outcomes}
\end{center}

\begin{center}
	\includegraphics[scale=0.5]{new_grover_for_1_bit_strings_l2_outcomes.png}
	\captionof{figure}{Resultado Grover modificado encodado uma bit-string de 2 bits}
	\label{fig:l2-grover-new-outcomes}
\end{center}



Com isso, para ter o melhor dos dois mundos, foi usado uma versão hibrida do algoritmo. Assim, para criar o circuito, é passado o valor a ser encodado por uma Look-Up-Table com os ângulos otimizados. Dessa forma, é possível maximizar as probabilidades.

\subsubsection{Diferença de conjuntos}

Utilizando dois Phase Oracles distintos, com ranges de valores diferentes, ao serem sobrepostos, é realizada a operação de diferença de conjuntos \cite{sanchezrivero2023initial}.

\begin{center}
	\includegraphics[scale=0.3]{less_than.png}
	\captionof{figure}{Exemplo - diferença de conjuntos}
	\label{fig:less-than-circuit}
\end{center}

Nesse exemplo \ref{fig:less-than-circuit} foi encodado no primeiro Oracle o set $\{000, 001, 010, 0110\}$ e no segundo $\{000, 001, 010, 011, 100, 101\}$.

\begin{center}
	\includegraphics[scale=0.5]{less_than_unitary.png}
	\captionof{figure}{Resultado da diferença de conjuntos}
	\label{fig:less-than-circuit-unitary}
\end{center}

Como pode ser visto em \ref{fig:less-than-circuit-unitary}, apenas os valores $\{100, 101\}$ permaneceram com a fase, representando então a sobreposição delas.


\subsubsection{Solução}

Para a solução do problema, foi criado uma hash function $C: v \to c$, da qual $v$ é o path de um arquivo e $c$ uma bit-string respectiva. Com essa função em mãos, podemos utilizar o conjunto dos valores retornados e encodá-los em um Phase Oracle, agindo como uma Look-Up-Table para os arquivos existentes na máquina.

No entanto, para ter sucesso na pesquisa, é necessário utilizar um segundo Oracle encondando $F = P-f$, sendo $f$ o conjunto de arquivos do qual estamos procurando e $F$ os arquivos restantes, aproveitando-se então da diferença de conjuntos para encontrar apenas os valores desejados na pesquisa.
Sendo assim, o primeiro Oracle age como o HD da máquina, marcando todos os arquivos existentes, e o segundo age como o mediador da pesquisa.

\begin{center}
	\includegraphics[scale=0.6]{sets-difference-look-up-table-oracle.png}
	\captionof{figure}{Diferença de conjuntos com as Look-Up-Tables}
	\label{fig:luts}
\end{center}


Por fim, é usado o aprimoramento dos ângulos para conseguir melhores probabilidades.

\begin{center}
	\includegraphics[scale=0.6]{improved_file_explorer.png}
	\captionof{figure}{Explorador de arquivos implementação}
	\label{fig:file-explorer}
\end{center}

Dessa forma, o arquivo procurado tem sua probabilidade maximizada pelo circuito e então a bit-string se apresenta após $n$ medições.


%insert image here
%insert image here(fake backend)

\subsubsection{Resultados}

Para um caso hipotético de um sistema operacional quântico, certamente essa é um das maneiras mais obvias para fazer buscas na imensidão dos arquivos armazenados. Para esse caso, não há escapatória, certamente essa seria, provavelmente, a melhor maneira de realizar essa ação.

Contudo, utilizar esse modelo em um sistema clássico tomando proveito da computação quântica não se mostra como a melhor opção, uma vez utilizar a estrutura linear de uma Look-Up-Table pode ser custoso a medida que a quantidade de arquivos crescem, além de aumentar gradativamente a probabilidade de colisões com relação a hash function. Para sistemas convencionais, dos quais utilizam métodos baseados em árvores, não é possível tirar qualquer proveito aqui.

\begin{center}
	\includegraphics[scale=0.5]{algorithms-finding-comparation.png}
	\captionof{figure}{Comparação algoritmos usados na pesquisa}
	\label{fig:file-explorer-comparation-O}
\end{center}

Sendo assim, o algoritmo de Grover deve ser pensando para casos do qual a versão clássica possui complexidade $\ge O(n)$.


\subsection{Milhas para Quilômetros} \label{conversion}

O segundo problema testado foi a conversão de milhas para quilômetros. Essa ideia se deu após a descoberta de um algoritmo capaz de calcular a sequência de Fibonacci usando circuitos quânticos.

\subsubsection{Algoritmo Quântico de Fibonacci}

A versão quântica usada para calcular Fibonacci foi apresentada em \cite{gilliam2020canonical} e  demonstra que, utilizando um circuito que coloca em superposição todas as bit-strings com $n$ qubits, e então realizando operações para remover valores que possuem $1$s consecutivos, é possível encontrar o valor $n$ na sequência.

Esse circuito pode ser criado da seguinte maneira, como descrito no artigo original \cite{gilliam2020canonical}:

\begin{center}
	\includegraphics[scale=0.3]{fibonacci-circuit.png}
	\captionof{figure}{Exemplo Algoritmo Quântico de Fibonacci}
	\label{fig:fibonacci-circuit}
\end{center}

Assim, ao executá-lo, temos:

\begin{center}
	\includegraphics[scale=0.5]{fibonacci-4.png}
	\captionof{figure}{Resultado exemplo Fibonacci - F(4)}
	\label{fig:fibonacci-circuit-result}
\end{center}

Aqui, as bit-strings em si não são importantes para o resultado, mas apenas a quantidade de bit-strings diferentes que aparecem com valores não $0$s.\\ 
No exemplo em \ref{fig:fibonacci-circuit-result}, foram usados $4$ qubits para calcular $F(4)$. Assim, ao contar as bit-strings, temos $F(4) = 8$, retornando então o quarto valor da sequência (nesse caso, a sequência começa do valor $2$, seguindo dessa forma: $F(1)=2, F(2)=3, F(3)=5, F(4)=8, F(5)=13, F(6)=21, ...$). \\
Com isso, é possível usar esse circuito para computações de $F(n)$ utilizando $n$ qubits para encontrar o valor requisitado na posição $n$.

\subsubsection{Aproximação de Milhas para Quilômetros usando Fibonacci}

Para aproximar o valor de milhas para quilômetros, podemos utilizar a sequência de Fibonacci com a seguinte relação: $F_{km} = F_{milhas}(n+1)$, sendo aqui $F$ a versão clássica de Fibonacci com $F(1) = 1$ e $F(2) = 2$. Dessa forma, se a posição $n$ é conhecida, valor aproximado em quilômetros será dado em $n+1$.


\begin{table}[!h]
	\begin{center}
		\begin{tabular}{ |c|c| } 
			\hline
			milhas & km \\
			\hline
			1 & 2 \\
			\hline
			2 & 3 \\
			\hline
			3 & 5 \\
			\hline
			5 & 8 \\
			\hline
		\end{tabular}
	\caption{valores aproximados de Milhas para Quilômetros}
	\end{center}
\end{table}

Valores não presentes na sequência, podem ser aproximados repartindo o valor em partes menores lá presentes. Por exemplo, para transformar $10$ milhas em quilômetros, podemos fazer: $F(4+1) + F(2+1)$, ou seja $13 + 3 \approx 16$, aproximando então do valor mais preciso de $\approx 16.0934$


\subsubsection{Implementação do circuito}

Com essa formulação, foi criado um algoritmo clássico para quebrar um número desejado em partes menores, as quais podem ser calculadas em um circuito quântico, este então retorna tuplas mapeando a entrada para o valor $n_i$ e a quantas vezes que é necessário a sua aplicação $i$ sendo assim : $ f: (n) \to ((n_1, i), (n_2, i), ...)$.

O algoritmo final segue o fluxo:

\begin{algorithm}
	\begin{algorithmic}
		\State{partes = $quebraValor(valorDeEntrada)$}
		\For{parte in partes}
			\State{Aplique o Oracle $F(parte)$}
			\State{Faça as medições nos qubits}
			\State{Reset os qubits usados}
		\EndFor
		\State{verifique o resultado de cada bit-string}
		\State{Multiplique cada resultado com o valor $i$ correspondente}
		
	\end{algorithmic}
	\caption{Algoritmo quântico para a conversão}
	\label{alg:miles-to-km-quantum-algortihm}
\end{algorithm}

\begin{center}
	\includegraphics[scale=0.15]{number_breakdown_circuit.png}
	\captionof{figure}{Circuito de conversão}
	\label{fig:miles-km-circuit}
\end{center}

\subsubsection{Resultados}

Usando esse método é possível alcançar os valores esperados. Contudo existem alguns pontos que tornam esse método inviável:

\begin{enumerate}
\item{Quantidade necessária de medições e tempo de execução}\\
Para cada vez que medirmos o circuito, precisamos de uma quantidade alta de \emph{shots} para alcançar um resultado melhor, aumentando também o tempo necessário para executar.

\begin{center}
	\includegraphics[scale=0.6]{comparison_miles_to_km.png}
	\captionof{figure}{Comparação tempos de execução}
	\label{fig:comparasion-miles-km-time}
\end{center}

Como mostrado em \ref{fig:comparasion-miles-km-time}, o tempo das versões clássicas, com e sem memoization, possuem tempos praticamente constantes em relação as versões quânticas.


\item{Erros}\\
Como a maioria dos algoritmos Quânticos da era NISQ(noisy intermediate-scale quantum), os erros também estão presentes, e por serem utilizados inúmeros gates multi-qubits, esses erros podem se intensificar de acordo com hardware usado.

\item{Imprecisão}\\

\begin{center}
	\includegraphics[scale=0.2]{miles_to_km_defiance.png}
	\captionof{figure}{Comparação resultados versão clássica e quântica}
	\label{fig:values-miles-km-quantum}
\end{center}

Como mostrado em \ref{fig:values-miles-km-quantum}, valores pequenos possuem uma boa precisão com os números esperados(em azul), mas a partir de certo ponto eles começam a se distanciar e perdem totalmente a precisão.

\item{Necessidade de intervenção clássica}

Por fim, esse algoritmo requer que primeiro seja verificado quais são os valores de Fibonacci necessários para cada parte(pré-processamento), além de ser necessário pós processamento após as medições. Sendo assim, a maior parte do tempo está sendo realizada computação clássica ao invés de quântica, o que acaba diminuindo a utilidade de um computador quântico aqui.

\end{enumerate}

Sendo assim, esse algoritmo não consegue se sair bem como a versão clássica, além de ser mais custoso na maioria dos casos. Para de fato evoluir essa implementação, será necessário remodelá-lo para um versão independente ou ainda com pouca computação clássica, priorizando a maneira como dados podem ser encodados e transformados no circuito.

\subsection{Torres de Hanoi} \label{hanoi}

Para a criação das torres de Hanoi, foi pensado em uma maneira de encodar a posição dos discos na torre utilizando seus valores binários e o Phase Oracle como meio de armazenamento.

\subsubsection{Implementação}

Para esse projeto, são necessários $(\floor{\log_2{x}} + 1) * 3$ qubits, sendo $x$ o número de discos. Estes seguem a ordem, $\ket{t_{n-1} t_{n-2} ... t_0}\ket{a_{n-1} a_{n-2} ... a_0}\ket{s_{n-1} s_{n-2} ... s_0}$, sendo $s$,$a$,$t$ a primeira, segunda e última torre respectivamente, e $n = {{n \space qubits} \over 3}$.

Com essa configuração, os números de $1$ à $x$ são codificados em seu formato binário nos qubits $s$, utilizando a fase global $\pi$. Em seguida, são realizadas operações de $swap$ bit-a-bit para mover os valores do $n$ $ls-$qubits  para os $n$ $ms-$qubits.

Para realizar essas operações, é necessário pré-calcular a sequência de movimentos usados  \cite{ldiaandr_2021_tower} \cite{diptokarmakar47_2019_how} \cite{a2020_towers}  \cite{geeksforgeeks_2014_program}. Dessa forma, essa versão quântica age como um jogador com uma lista de passos a serem seguidos, executando-os um-a-um.

\begin{center}
	\includegraphics[scale=0.3]{hanoi_3_discs.png}
	\captionof{figure}{Torre de Hanoi com 3 discos}
	\label{fig:hanoi}
\end{center}

Nesse formato, pode-se utilizar outras partes no circuito, como o algoritmo de Grover, para verificar o resultado ou executar outras operações nos valores.

\begin{center}
	\includegraphics[scale=0.5]{result_hanoi_3_discs.png}
	\captionof{figure}{Resultado usando Grover - Torre de Hanoi com 3 discos}
	\label{fig:hanoi-result}
\end{center}

Em \ref{fig:hanoi-result}, os $3$ maiores resultados obtidos são as bit-strings com $01$, $10$ e $11$ nos bits mais significativos. Sendo assim, o resultado esperado para uma torre com 3 discos, foi atingido.

\subsubsection{Resultados}

Nessa versão, é seguida a mesma sequência do algoritmo clássico, necessitando, inclusive, de pré-processamento para conseguir a sequência de ações.\\
Em uma versão clássica, o movimento de retirar um disco de uma torre e move-lo para a próxima torre requer também esse pré-processamento, podendo ser realizado um-a-um ou tudo de uma vez antes da partida. Dessa forma, a versão clássica e quântica se igualam, não tendo ganhos ou perdas expressivas. 

\subsection{Buckshot Roulette} \label{buckshot}

\emph{Buckshot Roulette} é um jogo de computador feito pelo desenvolvedor \href{https://mikeklubnika.itch.io/}{Mike Klubnika}, tomando como base a premissa de reinventar a infame roleta russa. No jogo, você é desafiado por um demônio (dealer), e caso você ganhe, uma recompensa lhe será dado, caso contrário o jogo reinicia e você pode tentar novamente.

Nesse projeto, foi tomado como objetivo analisar a primeira rodado do jogo e tentar encontrar a melhor estratégia para maximizar os ganhos do jogador. O motivo da escolha da primeira rodada se dá tanto pela sua simplicidade, o que facilitou os testes, como por manter muito bem a essência do jogo.

\subsubsection{Dinâmica}

Na rodada, são colocadas $2$ balas falsas e $1$ bala verdadeira na arma, sendo o player o primeiro a jogar. Ambos os jogadores podem escolher entre atirar em si mesmo, ou em seu oponente. Assim, a próxima ação é estritamente depende das probabilidades de ser uma bala real ou falsa. \\
A partir dai, a dinâmica funciona da seguinte forma: 

\begin{algorithm}[H]
	\begin{algorithmic}
		\If{jogador escolhe atirar no dealer}
			\If{bala for real}
				\State{Jogador ganha a rodada}
			\Else
				\State{Dealer joga a próxima}
			\EndIf
		\Else
			\If{bala for real}
				\State{Jogador perde}
			\Else
				\State{Player joga a próxima}
			\EndIf
		\EndIf

	\end{algorithmic}
	\caption{Possíveis jogadas}
	\label{alg:buckshot-roulette}
\end{algorithm}



\subsubsection{Versão clássica}

Para entender melhor a dinâmica, é possível representar cada ação e suas consequências em formato de árvore. Dessa forma, cada jogada leva a partida para mais próximo do fim.


\begin{center}
	\includegraphics[scale=0.2]{buckshot-roulette-diagram.png}
	\captionof{figure}{Buckshot Roulette diagrama de árvore}
	\label{fig:classical-model-bckr}
\end{center}

Nessa estrutura, é previsto que o Jogador seja um agente racional e o dealer uma máquina com ações aleatórias. Assim, o jogador sempre visa o seu benefício, enquanto o dealer age pela sorte. \\
Tal comportamento pode ser visto nas folhas da árvore, do qual sempre que o player é o próximo jogador, sua ação é apenas atirar no adversário, enquanto o dealer ainda possui a possibilidade de entregar o jogo atirando em si próprio, mesmo havendo apenas uma bala na arma e, pela lógica do jogo, ser uma bala verdadeira.

Seguindo essa estrutura, podemos simular os possíveis caminhos e verificar a melhor estratégia.

\begin{center}
	\includegraphics[scale=0.6]{optimal_player_strategy.png}
	\captionof{figure}{Buckshot Roulette clássico - melhor estratégia}
	\label{fig:classical-model-bckr-optimal-strategy}
\end{center}

Após testar os possíveis caminhos, o melhor resultado obtido foi esse apresentado acima em \ref{fig:classical-model-bckr-optimal-strategy}. Com um pouco de investigação, foi possível entender que essa estratégia se baseia no jogador começar atirando no dealer. Isso acontece, pois, ao seguir tal caminho, ele tem uma chance a menos de perder a rodada, já que a chance de ser eliminado logo no começo desaparece.

\begin{table}[!h]
	\begin{center}
		\begin{tabular}{ |c|c|c|c| } 
			\hline
			rodada & ação & resultado da ação & resultado da partida \\
			\hline
			1 & player atira no dealer  & real & player ganha\\
			\hline
			1 & player atira no dealer  & fake & -\\
			\hline
			2 & dealer atira no player  & real & dealer ganha\\
			\hline
			2 & dealer atira no player  & fake & -\\
			\hline
			2 & dealer atira nele mesmo  & real & player ganha\\
			\hline
			2 & dealer atira nele mesmo  & fake & -\\
			\hline
			3 & player atira no dealer  & real & player ganha\\
			\hline
			3 & dealer atira no player & real & dealer ganha\\
			\hline
			3 & dealer atira nele mesmo  & real & player ganha\\
			\hline
		\end{tabular}
		\caption{melhor estratégia - possíveis resultados}
	\end{center}
\end{table}

Assim, o dealer tem duas chances de ganhar, enquanto o player possui 4.

\subsubsection{Versão quântica}

A partir dessa ideia, um circuito quântico foi modelado imitando o funcionamento do game. Nesse algoritmo, um Oracle foi usado para cada jogador, implementando internamente sua estratégia.

\begin{center}
	\includegraphics[scale=0.3]{quantum_buckshot_roulette.png}
	\captionof{figure}{Circuito para o Buckshot Roulette}
	\label{fig:bckr-circuit}
\end{center}

Além disso, para encontrar a estratégia, foram inseridos dois parâmetros dentro do Oracle do player, sendo possível configurar qualquer valor $\theta$ e $\phi$ para modificar a rotação na Bloch Sphere.

Após verificar os possíveis valores, a rotação que entregou o melhor resultado foi $\theta\approx 3.0853981633974477, \phi\approx3.7853981633974474$. Usando essa estratégia, os resultados foram semelhantes a versão clássica.

\begin{center}
	\includegraphics[scale=0.6]{final_buckshot_roulette_quantum_optimal_strategy.png}
	\captionof{figure}{Resultado Buckshot Roulette quântico - Qiskit AER}
	\label{fig:bckr-circuit-result}
\end{center}

Observando a Bloch Sphere do estado gerado por essa rotação, é possível ver também que a estratégia, de fato, se assemelha a versão clássica, com o player preferindo atirar no dealer a maior parte do tempo (o valor $1$ aqui representa atirar no outro jogador e $0$ em si mesmo).

\begin{center}
	\includegraphics[scale=0.6]{player_optimal_strategy_bloch.png}
	\captionof{figure}{Melhor estratégia Buckshot Roulette quântico - Bloch Sphere}
	\label{fig:bckr-bloch-sphere-best-strategy}
\end{center}

\subsubsection{Conclusões}

Para esse problema, não há uma competição certa entre as duas versões, já que uma é diretamente inspirada na outra. Além disso, a versão quântica possui ainda a possibilidade de explorar mais valores do que a versão clássica, deixando o player mais aberto a escolha de estratégias, o que pode ser visto como um ponto a favor da versão quântica.

Em relação a erros providos pelo hardware, isso não afetou diretamente os resultados, uma vez que, mesmo com os erros, a proporção se manteve.

 \begin{center}
 	\includegraphics[scale=0.6]{final_buckshot_roulette_quantum_optimal_strategy_Fake20QV1.png}
 	\captionof{figure}{Resultado Buckshot Roulette quântico - Fake20QV1 Qiskit}
 	\label{fig:bckr-fake-melbourne}
 \end{center}

Note também, que o total de partidas ganhas não chega ao total jogado, nesse caso $1000$ partidas foram simuladas. Isso acontece, devido ao design do circuito, do qual não é possível verificar a jogada do player anterior, sendo possível continuar jogando, mesmo que um dos players já tenha perdido, o que se fez necessário correções usando pós processamento após receber os resultados.

Em suma, ambos as simulações atingiram o mesmo resultado e foi demonstrado que é possível usar o quantum Oracle como uma representação de um player dentro do circuito.

\subsection{QRAM} \label{qram}

Por fim, o último projeto realizado foi o de uma \emph{QRAM} utilizando os Oracles. Nessa versão, foi testado a criação de \emph{QROMs} (com dados estáticos dentro), e uma possível maneira de utilizar uma QRAM hábil para escrita.

Neste projeto, foi tido como objetivo o armazenamento de estados quânticos(superposições), e não apenas de bit-strings clássicas. Isso pois, para garantir a real eficiência da computação quântica, a superposição é indispensável, e seu armazenamento pode ser um ponto chave para algoritmos melhores.

\subsubsection{QROM}

Para a QROM, são utilizados $n$ qubits para o barramento de endereços e $m$ qubits para a o barramento de dados, sem a necessidade desses valores estarem correlacionados, podendo assim ser utilizado $n=3, m=10$. Nessa estrutura, podemos mapear diversas superposições diferentes e aplicá-las quando certo endereço for chamado. Sendo assim, o algoritmo armazena os valores a partir da configuração de gates controlados interiores ao Oracle, criando uma superposição apenas quando certo valor de entrada é inserido.

A entrada do circuito segue o seguinte formato: ${\ket{0}^{\otimes m}} {\ket{a_{n-1} a_{n-2} ... a_0}}$

\begin{center}
	\includegraphics[scale=0.5]{qrom_1.png}
	\captionof{figure}{Exemplo circuito - QROM}
	\label{fig:qrom}
\end{center}


Em \ref{fig:qrom}, $q_{0}$ age como o barramento de endereços, enquanto $q_{1}$ como o barramento de dados. Aqui configuramos para mapear o endereço $0 \to RY({\pi\over{3}})$ e $1 \to H$. Sendo assim, para $n$ qubits no barramento de endereços é possível mapear para $2^{n}$ estados, e com os $m$ qubits é possível criar estados mais complexos aumentando sua quantidade e utilizando outros gates para isso.

A partir desse circuito, basta abstrai-lo para um Oracle e utilizar em um circuito maior, chamando-o novamente sempre que for necessário um certo estado ou ainda colocar os endereços em superposição e ter uma mistura de estados na saída.

\begin{center}
	\includegraphics[scale=0.5]{qrom_1_usage.png}
	\captionof{figure}{Exemplo circuito usando a QROM}
	\label{fig:qrom-usage}
\end{center}

Nesse exemplo \ref{fig:qrom-usage}, os estados em superposição serão colocados no qubit denominado \emph{out}, sendo possível se aproveitar dela em outros qubits, como nesse caso o qubit \emph{q}.

Contudo, devido ao no-cloning-theorem, não é possível copiar esse estado para outro qubit alvo, então, dessa forma, não é possível ter dois qubits com o mesmo estado a partir do armazenado. Uma opção para isso, é utilizar do teleporte quântico para destruir o estado interno do Oracle e mover para outros qubits desejados, contudo isso influenciária nos estados já aplicados no circuito.


\subsubsection{QRAM}

Para criar uma QRAM com a habilidade de escrita, o teleporte quântico já citado antes é um caminho para isso. Com ele, podemos ter $n$ qubits, sendo cada qubit um endereço único, e utilizar do teleporte para mover um estado que estava no circuito, para o domínio da QRAM.

 \begin{center}
 	\includegraphics[scale=0.4]{qram.png}
 	\captionof{figure}{Exemplo circuito - QRAM}
 	\label{fig:qram}
 \end{center}

Aqui, são necessários $n$ qubits para $n$ endereços (\emph{data}) também agindo como qubits de data, e $n$ qubits para o teleporte (\emph{t}), crescendo então de forma linear à capacidade de armazenamento de dados deste. 
Também é possível sobre-escrever valores, assim como interferir com outras superposições apenas teleportando novos valores para o qubit $i$. Dessa forma, podemos criar uma memória menor, e, conforme necessário, remover e adicionar outros valores.

\subsubsection{Conclusões}

Com esse projeto, e com a literatura usada \cite{jaques2023qram}\cite{Giovannetti_2008}, é possível entender que criar versões quânticas de memória é uma tarefa desafiadora, e ainda não é possível tomar proveito do todo o seu potencial usando as superposições e estados de outras bases a não ser a base computacional $({0,1})$. Fatores como, complexidade de mapear dados, complexidade de utilizar a memória (já que é necessário reaplica-lá toda vez que for requisitado seu uso), no-cloning-theorem, decorrência, etc. Influenciam diretamente na possibilidade de sua criação.

Mesmo sendo possível implementar pequenos circuitos que agem como memória, como os mostrados aqui, ainda não é usual e muito menos universal para qualquer tipo de máquina quântica.

Assim como mostrado na literatura, o melhor approach para a sua implementação, é a utilização de um hardware especifico para isso, sem a intervenção de circuitos quânticos, mantendo depth do algoritmo implementado constante ajudando assim a manter a coerência do circuito. 

Em suma, mesmo sendo possível criar pequenos circuitos para implementar uma memória, seu uso está longe de se comparar as versões clássicas.

\subsection{Conclusão}

Perante o exposto, foi evidenciado que a computação quântica ainda tem muito potencial. No entanto, é possível ver que certos fatores e a falta de alguns recursos, prejudicam o seu uso, no momento.

Como já mostrado pelas inúmeras pesquisas em áreas como, química, machine learning, criptografia, otimização, etc. A computação quântica pode no futuro ser um ponto crucial para conseguir resultados mais precisos e, em certos casos, em menor tempo. No entanto, na era NISQ, para conseguir utilizar todo seu potencial, é necessário ter em conjunto máquinas clássicas para pré e/ou pós processamento. Assim como demonstrado aqui, ao utilizar esse conjunto, é possível ter o melhor dos dois mundos, mesmo que na maioria do casos, esse formato de implementação não se sobressaí as versões já utilizadas, com o tempo, e o aperfeiçoamento das técnicas e do hardware em si darão um novo caminho para novos usos.

Em resumo, é possível tirar proveito da computação quântica para problemas que conhecemos classicamente. No entanto, é necessário averiguar se há algum fator quântico que pode ser explorado que em sua forma clássica seria impossível ou não usuais.

\nocite{SOARE2009368}
\nocite{odonnell_2015_lecture}
\nocite{bacon_2006_cse}
\nocite{lipics_stacs}
\nocite{odonnell_2015_lecture_2}
\nocite{brodkorb_2019_the}
\nocite{amreen_oracle}
\nocite{kalyanasyndaram_2021_mod04lec23}
\nocite{davis_2006_turing}
\nocite{viswanathan_2013_reductions}
\nocite{Fan_2007}
\nocite{cryptoeprint:2020/1270}
\nocite{buhrman1998quantum}
\nocite{sanchezrivero2023initial}
\nocite{gilliam2020canonical}
\nocite{Kashefi_2002}
\nocite{e21080800}
\nocite{Zeng_2014}
\nocite{atici2004comparative}
\nocite{sundarappan_2022_how}
\nocite{dai_view}
\nocite{sep-game-theory}
\nocite{Giovannetti_2008}
\nocite{jaques2023qram}
\nocite{PythonEWL2022}
\nocite{frackiewicz2011application}
\nocite{Eisert_1999}
\nocite{usman_2019_kilometres}
\nocite{ldiaandr_2021_tower}
\nocite{diptokarmakar47_2019_how}
\nocite{a2020_towers}
\nocite{geeksforgeeks_2014_program}
\nocite{khan_2021_quantum}
\nocite{legn_2022_dilemma}
\nocite{siegelwax_2022_quantum}
\nocite{landi_density}
\nocite{bacon_2006_cse}
\nocite{vijayakrishnan_2019_role}
\nocite{python_scientific}
\nocite{scipyoptimizeminimize_scalar}
\nocite{davis_optimization}
\nocite{scipyoptimizeminimize}



\bibliographystyle{unsrt}
\bibliography{references}


\end{document}
